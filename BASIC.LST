     1                                      [map all BASIC.MAP]
     2                                      [DEFAULT REL]
     3                                      BITS 64
     4                                  Segment .text align=1
     5                                  %include "RELOC.ASM"
     6 00000000 55AA                <1>     dw 0AA55h 
     7                              <1> ;First verify I have Enough RAM for my program and then run
     8 00000002 B801E80000          <1>     mov eax, 0E801h ;Get low memory count in ax
     9 00000007 CD35                <1>     int 35h
    10 00000009 663D0008            <1>     cmp ax, 200000h/400h ;Divide 2Mb into 1Kb chunks.
    11 0000000D 722A                <1>     jb bad
    12 0000000F B9000100C0          <1>     mov ecx, 0C0000100h ;Read FS MSR
    13 00000014 0F32                <1>     rdmsr
    14 00000016 89D7                <1>     mov edi, edx        ;Get the hi dword, and clear the upper bytes
    15 00000018 48C1E720            <1>     shl rdi, 20h        ;Shift high
    16 0000001C 89C7                <1>     mov edi, eax        ;Get the low dword in
    17 0000001E 4889F8              <1>     mov rax, rdi
    18 00000021 488D35(00000000)    <1>     lea rsi, section.resSeg.start
    19 00000028 4881C7[9AF90300]    <1>     add rdi, bssLen
    20 0000002F B900100000          <1>     mov ecx, 1000h
    21 00000034 F348A5              <1>     rep movsq
    22 00000037 FFE0                <1>     jmp qword rax
    23                              <1> bad:
    24 00000039 488D2D0D000000      <1>     lea rbp, badmsg
    25 00000040 B804130000          <1>     mov eax, 1304h
    26 00000045 CD30                <1>     int 30h
    27 00000047 30E4                <1>     xor ah, ah
    28 00000049 CD36                <1>     int 36h
    29 0000004B CD38                <1>     int 38h
    30 0000004D 4E6F7420456E6F7567- <1> badmsg: db "Not Enough Memory. Press any key to enter SYSDEBUG...",0
    30 00000056 68204D656D6F72792E- <1>
    30 0000005F 20507265737320616E- <1>
    30 00000068 79206B657920746F20- <1>
    30 00000071 656E74657220535953- <1>
    30 0000007A 44454255472E2E2E00  <1>
     6                                  Segment dSeg nobits align=1 start=0
     7                                  %include "BSS.ASM"
     8 00000000 <res FC0h>          <1> stack       resq 200h - 8  ;Save 4Kb stack space
     9 00000FC0 ????????????????    <1> stacktop    resq 1
    10                              <1> 
    11                              <1> maxVars     equ 26
    12 00000FC8 <res D0h>           <1> varTbl      resq maxVars    ;Variables A-Z
    13                              <1> 
    14                              <1> maxLineLen  equ 256
    15 00001098 <res 100h>          <1> inString    resb maxLineLen        ;256 character input string
    16                              <1> 
    17                              <1> maxProgLen  equ 1000    ;Max 1000 lines of code
    18                              <1> progSize    equ maxLineLen*maxProgLen
    19                              <1> 
    20 00001198 <res 3E800h>        <1> progspace   resb progSize
    21                              <1> 
    22 0003F998 ??                  <1> strLen      resb 1  ;Counter for number of chars entered in string
    23 0003F999 ??                  <1> stateByte   resb 1  ;TROFF/TRON etc, unused for now
    24                              <1> bssLen: ;Needed to compute the resident portion load location
     8                                  Segment resSeg follows=.text align=1 vfollows=dSeg valign=1
     9                                  %include "MAIN.ASM"
    10                              <1> start:
    11 00000000 B800050000          <1>     mov eax, 0500h  ;Set page zero as the default page
    12 00000005 CD30                <1>     int 30h
    13 00000007 B402                <1>     mov ah, 02h
    14 00000009 31D2                <1>     xor edx, edx    ;Set screen cursor to top right corner
    15 0000000B 88D7                <1>     mov bh, dl      ;Set cursor for page 0
    16 0000000D CD30                <1>     int 30h
    17 0000000F B707                <1>     mov bh, 07h     ;Grey/Black attribs
    18 00000011 B800060000          <1>     mov eax, 0600h  ;Clear whole screen
    19 00000016 CD30                <1>     int 30h
    20 00000018 FC                  <1>     cld
    21 00000019 E86E010000          <1>     call cleanProgram
    22 0000001E 488D2DE3010000      <1>     lea rbp, mainmsg
    23 00000025 B804130000          <1>     mov eax, 1304h
    24 0000002A CD30                <1>     int 30h
    25 0000002C B801E80000          <1>     mov eax, 0E801h
    26 00000031 CD35                <1>     int 35h
    27 00000033 25FFFF0000          <1>     and eax, 0FFFFh
    28 00000038 48C1E00A            <1>     shl rax, 0Ah    ;Convert Kb to bytes
    29 0000003C E80F010000          <1>     call printdecimalword
    30 00000041 488D2DDC010000      <1>     lea rbp, bytemsg
    31 00000048 B804130000          <1>     mov eax, 1304h
    32 0000004D CD30                <1>     int 30h
    33 0000004F C605(98F90300)00    <1>     mov byte [strLen], 0
    34                              <1> mainLoop:
    35 00000056 488D25(C00F0000)    <1>     lea rsp, stacktop    ;Reinitialize stack pointer
    36 0000005D 488D05F2FFFFFF      <1>     lea rax, mainLoop
    37 00000064 50                  <1>     push rax
    38 00000065 488D2D97010000      <1>     lea rbp, prompt
    39 0000006C E8D2000000          <1>     call ttyOutString
    40 00000071 E830000000          <1>     call getLineInput
    41 00000076 E801000000          <1>     call saveExecuteLine
    42 0000007B C3                  <1>     ret
    43                              <1> saveExecuteLine:
    44                              <1> ;This function will execute the line if it is an interactive expression
    45                              <1> ; or store it in the program if it has a line number
    46 0000007C 488D3D(98100000)    <1>     lea rdi, inString
    47 00000083 4889FB              <1>     mov rbx, rdi
    48 00000086 8A0D(98F90300)      <1>     mov cl, byte [strLen]   ;Get number of chars in string
    49 0000008C B020                <1>     mov al, 20h ;Skip preceeding spaces
    50 0000008E F3AE                <1>     repe scasb  ;IF the first char in the string is a question mark => Interactive
    51 00000090 8A47FF              <1>     mov al, byte [rdi - 1]  ;Get the first non-space char into al
    52 00000093 4889DF              <1>     mov rdi, rbx    ;Return rdi to start of line
    53 00000096 3C3F                <1>     cmp al, "?"
    54 00000098 7505                <1>     jne .store
    55                              <1>     ;Attempt to execute line as is
    56 0000009A E98E000000          <1>     jmp criticalError
    57                              <1> .store:
    58                              <1>     ;Now look for line number, if it exists, place it at position, else error
    59 0000009F B903000000          <1>     mov ecx, 3  ;Line numbers can be between 0 and 999
    60 000000A4 C3                  <1>     ret
    61                              <1> executeLine:
    62 000000A5 C3                  <1>     ret
    63                              <1> getLineInput:
    64 000000A6 30E4                <1>     xor ah, ah
    65 000000A8 8825(98F90300)      <1>     mov byte [strLen], ah   ;Zero the char counter
    66 000000AE 488D3D(98100000)    <1>     lea rdi, inString   ;Move to start of line
    67                              <1> .getChar:
    68 000000B5 E891000000          <1>     call ttyIn
    69 000000BA 3C0D                <1>     cmp al, 0Dh ;Line Feed
    70 000000BC 7456                <1>     je .gliExit
    71 000000BE 3C08                <1>     cmp al, 08h ;Bspace
    72 000000C0 740F                <1>     je .glibspace
    73 000000C2 803D(98F90300)FF    <1>     cmp byte [strLen], -1   ;If at max length, simply beep and wait for either bspace or enter
    74 000000C9 7456                <1>     je .gliFull 
    75 000000CB 84C0                <1>     test al, al
    76 000000CD 7443                <1>     je .gliExtendedChar
    77 000000CF EB29                <1>     jmp short .gliCheckCase
    78                              <1> .glibspace:
    79 000000D1 F605(98F90300)FF    <1>     test byte [strLen], -1  ;This will only be zero if strLen=0
    80 000000D8 74DB                <1>     jz .getChar
    81 000000DA 48FFCF              <1>     dec rdi ;Go back by one position in the input line
    82 000000DD FE0D(98F90300)      <1>     dec byte [strLen]
    83 000000E3 B008                <1>     mov al, 08h
    84 000000E5 E854000000          <1>     call ttyOutChar
    85 000000EA B020                <1>     mov al, 20h  
    86 000000EC E84D000000          <1>     call ttyOutChar
    87 000000F1 B008                <1>     mov al, 08h
    88 000000F3 E846000000          <1>     call ttyOutChar
    89 000000F8 EBBB                <1>     jmp short .getChar
    90                              <1> .gliCheckCase:
    91                              <1>     ;al has char
    92 000000FA E83F000000          <1>     call ttyOutChar ;Echo the char as is, but store it uppercase
    93 000000FF 3C61                <1>     cmp al, "a"
    94 00000101 7206                <1>     jb .gliccStore
    95 00000103 3C7A                <1>     cmp al, "z"
    96 00000105 7702                <1>     ja .gliccStore
    97 00000107 2C20                <1>     sub al, 20h
    98                              <1> .gliccStore:
    99 00000109 AA                  <1>     stosb   ;Increment the pointer, add char to buffer
   100 0000010A FE05(98F90300)      <1>     inc byte [strLen]   ;Inc char count
   101 00000110 EBA3                <1>     jmp short .getChar
   102                              <1> .gliExtendedChar:
   103                              <1>     ;Currently, extended chars do nothing, eventually add F1-F10 functionality
   104 00000112 EBA1                <1>     jmp short .getChar
   105                              <1> .gliExit:
   106 00000114 488D2D17010000      <1>     lea rbp, crlf
   107 0000011B E823000000          <1>     call ttyOutString
   108 00000120 C3                  <1>     ret
   109                              <1> .gliFull:
   110 00000121 B007                <1>     mov al, 07h
   111 00000123 E816000000          <1>     call ttyOutChar
   112 00000128 E988FFFFFF          <1>     jmp .getChar
   113                              <1> 
   114                              <1> ;For any error, syntax or otherwise, come here
   115                              <1> criticalError:
   116 0000012D 488D2D01010000      <1>     lea rbp, errmsg
   117 00000134 E80A000000          <1>     call ttyOutString
   118 00000139 E918FFFFFF          <1>     jmp mainLoop    ;Trash input line, restart line input
   119                              <1> 
   120                              <1> ;-------------------------------:
   121                              <1> ;---------Misc routines---------:
   122                              <1> ;-------------------------------:
   123                              <1> ttyOutChar:
   124 0000013E B40E                <1>     mov ah, 0Eh
   125 00000140 CD30                <1>     int 30h
   126 00000142 C3                  <1>     ret
   127                              <1> ttyOutString:
   128 00000143 B804130000          <1>     mov eax, 1304h
   129 00000148 CD30                <1>     int 30h
   130 0000014A C3                  <1>     ret
   131                              <1> ttyIn:
   132 0000014B 30E4                <1>     xor ah, ah
   133 0000014D CD36                <1>     int 36h
   134 0000014F C3                  <1>     ret
   135                              <1> 
   136                              <1> printdecimalword:
   137                              <1> ;Takes the qword in rax and prints its decimal representation
   138 00000150 4831C9              <1>     xor rcx, rcx
   139 00000153 31ED                <1>     xor ebp, ebp    ;Use bp as #of digits counter
   140 00000155 48BB0A000000000000- <1>     mov rbx, 0Ah  ;Divide by 10
   140 0000015E 00                  <1>
   141                              <1> .pdw0:
   142 0000015F FFC5                <1>     inc ebp
   143 00000161 48C1E108            <1>     shl rcx, 8    ;Space for next nybble
   144 00000165 31D2                <1>     xor edx, edx
   145 00000167 48F7F3              <1>     div rbx
   146 0000016A 80C230              <1>     add dl, '0'
   147 0000016D 80FA39              <1>     cmp dl, '9'
   148 00000170 7603                <1>     jbe .pdw1
   149 00000172 80C207              <1>     add dl, 'A'-'0'-10
   150                              <1> .pdw1:
   151 00000175 88D1                <1>     mov cl, dl    ;Save remainder byte
   152 00000177 4885C0              <1>     test rax, rax
   153 0000017A 75E3                <1>     jnz .pdw0
   154                              <1> .pdw2:
   155 0000017C 88C8                <1>     mov al, cl    ;Get most sig digit into al
   156 0000017E 48C1E908            <1>     shr rcx, 8    ;Get next digit down
   157 00000182 E8B7FFFFFF          <1>     call ttyOutChar
   158 00000187 FFCD                <1>     dec ebp
   159 00000189 75F1                <1>     jnz .pdw2
   160 0000018B C3                  <1>     ret
    10                                  %include "COMMANDS.ASM"
    11                              <1> cleanProgram:
    12 0000018C 488D3D(98110000)    <1>     lea rdi, progspace  ;Point to program area
    13 00000193 B9007D0000          <1>     mov ecx, progSize/8
    14 00000198 31C0                <1>     xor eax, eax
    15 0000019A F348AB              <1>     rep stosq         ;Clear program area
    16 0000019D C3                  <1>     ret
    17                              <1> funTbl:
    18 0000019E 044E4557            <1>     db 4,"NEW"
    19 000001A2 [8C01000000000000]  <1>     dq cleanProgram
    20                              <1>     
    21 000001AA 054C495354          <1>     db 5,"LIST"
    22                              <1> 
    23 000001AF 0452554E            <1>     db 4,"RUN"
    24                              <1> 
    25 000001B3 065052494E54        <1>     db 6,"PRINT"
    26                              <1> 
    27 000001B9 06494E505554        <1>     db 6,"INPUT"
    28                              <1> 
    29 000001BF 034946              <1>     db 3,"IF"
    30                              <1> 
    31 000001C2 05474F544F          <1>     db 5,"GOTO"
    32                              <1> 
    33 000001C7 0753595354454D      <1>     db 7,"SYSTEM"
    34                              <1> 
    35 000001CE 01                  <1>     db 1
    11                                  %include "MATH.ASM"
    12                              <1> decimalToHex:
    13                              <1>     ;Takes ASCII encoded decimal number and 
    14                              <1>     ;returns its hex value
    15                              <1>     ;Input: rsi = Start of string
    16                              <1>     ;       ecx = Number of Digits in digit string (max 255)
    17                              <1>     ;Output: rax = Number
    18 000001CF 53                  <1>     push rbx
    19 000001D0 52                  <1>     push rdx
    20 000001D1 57                  <1>     push rdi
    21 000001D2 55                  <1>     push rbp
    22 000001D3 FD                  <1>     std             ;Reverse string traversal direction
    23 000001D4 4889F7              <1>     mov rdi, rsi    ;Save pointer in rdi
    24 000001D7 4801CE              <1>     add rsi, rcx    ;Go to end of number string
    25 000001DA 31ED                <1>     xor ebp, ebp    ;Clear rbp, to store value in
    26 000001DC BB01000000          <1>     mov ebx, 1      ;Start with ebx = 1
    27                              <1> .processDigits:
    28 000001E1 AC                  <1>     lodsb           ;Get the first digit in al
    29 000001E2 2C30                <1>     sub al, 30h     ;Reduce to value
    30 000001E4 480FB6C0            <1>     movzx rax, al   ;Clear upper bits
    31 000001E8 31D2                <1>     xor edx, edx    ;Clear for multiplication
    32 000001EA 48F7E3              <1>     mul rbx         ;Multiply digit value by rbx
    33 000001ED 4801C5              <1>     add rbp, rax    ;Add value, overflows past 64 bit integers ignored
    34 000001F0 FEC9                <1>     dec cl          ;Decrement the number of chars left to process
    35 000001F2 7409                <1>     jz .exit        ;If now zero, exit!
    36 000001F4 4801DB              <1>     add rbx, rbx    ;Multiply by 2
    37 000001F7 488D1C9B            <1>     lea rbx, qword [rbx + 4*rbx] ;Multiply by 5
    38 000001FB EBE4                <1>     jmp short .processDigits
    39                              <1> .exit:
    40 000001FD FC                  <1>     cld             ;Return string traversal direction to normal
    41 000001FE 5D                  <1>     pop rbp
    42 000001FF 5F                  <1>     pop rdi
    43 00000200 5A                  <1>     pop rdx
    44 00000201 5B                  <1>     pop rbx
    45 00000202 C3                  <1>     ret
    12                                  %include "BASICDAT.ASM"
    13 00000203 4F6B0A0D00          <1> prompt  db "Ok",0Ah,0Dh,0
    14 00000208 5343522F363420496E- <1> mainmsg db "SCR/64 Integer BASIC v0.1",0Ah,0Dh,0
    14 00000211 746567657220424153- <1>
    14 0000021A 49432076302E310A0D- <1>
    14 00000223 00                  <1>
    15 00000224 204279746573206672- <1> bytemsg db " Bytes free",0Ah,0Dh,0
    15 0000022D 65650A0D00          <1>
    16 00000232 0A0D00              <1> crlf    db 0Ah,0Dh,0
    17 00000235 4572726F720A0D00    <1> errmsg  db "Error",0Ah,0Dh,0
    18 0000023D 303132333435363738- <1> numbers db "0123456789"
    18 00000246 39                  <1>
